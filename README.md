"# ExineClientAnalyze" 

ghidra_11.3.1_PUBLIC


---------fact check not yet!-----
[Thread::AddMessage]
메시지 타입별로 분기 처리:

case 3, 4: 소켓 연결 재설정
case 5: HandleIncomingTCPIPPacket - 들어오는 패킷 처리
case 6: ProcessSendPacketMessage - 패킷 전송 처리
case 7: CPacket 인코딩 후 전송
case 8: 포인터 설정
case 9: 직접 소켓 전송
case 0xc: 메모리 버퍼 관리
case 0xd, 0xe: 기타 처리


링버퍼에서 꺼낸 메시지의 첫 번째 매개변수가 메시지 타입이고, 나머지 매개변수들이 메시지 데이터입니다.
이 함수는 Thread의 가상함수를 오버라이드한 것으로, Thread에서 생성된 스레드가 링버퍼에서 메시지를 꺼내서 이 함수를 호출합니다.

즉, Thread::AddMessage → RingBuffer::AddElem → Socket::DispatchMessageW의 흐름으로 메시지가 처리됩니다!


---------fact check not yet!-----
SMultiServerPacket 구조 (각 서버 정보 0x60c = 1548 바이트):
오프셋크기내용
0x0 1 바이트 서버 타입/ID
0x4 4바이트서버 관련 정보
0x8 2바이트포트 번호
0x9 1바이트서버 상태
0xc 512바이트서버 이름 (유니코드)
0x20c 512바이트서버 IP 주소 (유니코드)
0x40c 512바이트서버 설명 (유니코드)
0x60c ...다음 서버 정보
요약:
ProcessMultiServer 함수는 서버로부터 받은 SMultiServerPacket을 파싱하여:

여러 서버들의 정보(이름, IP, 설명 등)를 추출
각 서버 정보를 클라이언트의 서버 목록에 추가
서버 목록을 로컬 파일로 저장

추정되는 실제 패킷 구조:
SMultiServerPacket:
- 헤더 (패킷타입 0x56 등)
- 서버 개수: 1바이트
- 각 서버마다:
  - 서버타입: 1바이트
  - 서버정보: 4바이트  
  - 포트: 2바이트
  - 상태: 1바이트
  - 서버이름길이: 2바이트
  - 서버이름: 가변길이 (유니코드)
  - IP주소길이: 2바이트
  - IP주소: 가변길이 (유니코드)
  - 설명길이: 2바이트  
  - 설명: 가변길이 (유니코드)
  
  --

Server.dat 파일은 암호화나 압축 없이 단순한 바이너리 형태로 저장됩니다.

------
pk
아인소프
케이네인
디토미아
콰브나토

npk
디아크리노
헤그네이아
프로네마
에이레네

SMultiServerPacket (0x56):
┌─────────────────────────────────────────────────────────────┐
│ [패킷 헤더]                                                 │
│   - 패킷 타입: 0x56                                         │
│   - 패킷 크기: 가변                                         │
├─────────────────────────────────────────────────────────────┤
│ [서버 정보 섹션]                                            │
│   - 총 서버 개수: 1바이트 (최대 8개)                       │
├─────────────────────────────────────────────────────────────┤
│ [PK 모드 서버들] (최대 4개)                                 │
│   └ 서버1:                                                  │
│     - 서버 타입: 1바이트 (0x00 = PK 모드)                  │
│     - 서버 ID: 4바이트                                      │
│     - 포트 번호: 2바이트                                    │
│     - 서버 상태: 1바이트 (온라인/오프라인/점검중)           │
│     - 서버 이름 길이: 1바이트                               │
│     - 서버 이름: 가변길이 (유니코드)                        │
│     - 서버 IP 길이: 1바이트                                 │
│     - 서버 IP: 가변길이 (유니코드)                          │
│     - 서버 설명 길이: 1바이트                               │
│     - 서버 설명: 가변길이 (유니코드)                        │
│     - 추가 정보 길이: 2바이트                               │
│     - 추가 정보: 가변길이 (접속자 수, 채널 정보 등)         │
│   └ 서버2: (동일 구조)                                      │
│   └ 서버3: (동일 구조)                                      │
│   └ 서버4: (동일 구조)                                      │
├─────────────────────────────────────────────────────────────┤
│ [NPK 모드 서버들] (최대 4개)                                │
│   └ 서버1:                                                  │
│     - 서버 타입: 1바이트 (0x01 = NPK 모드)                 │
│     - (나머지 구조는 PK 서버와 동일)                        │
│   └ 서버2: (동일 구조)                                      │
│   └ 서버3: (동일 구조)                                      │
│   └ 서버4: (동일 구조)                                      │
└─────────────────────────────────────────────────────────────┘

ProcessMultiServer에서의 처리 흐름:
// 1. 서버 개수 읽기
서버개수 = 패킷에서_읽기();  // 최대 8개

// 2. 각 서버 정보 파싱
for (int i = 0; i < 서버개수; i++) {
    서버타입 = 패킷에서_읽기();           // 0x00=PK, 0x01=NPK
    서버ID = 패킷에서_읽기();
    포트 = 패킷에서_읽기();
    상태 = 패킷에서_읽기();
    
    서버이름 = 길이와함께_문자열읽기();    // 1바이트 길이 + 유니코드
    서버IP = 길이와함께_문자열읽기();
    서버설명 = 길이와함께_문자열읽기();
    추가정보 = 길이와함께_데이터읽기();   // 2바이트 길이 + 데이터
    
    // 3. 메모리 구조체에 저장 (0x60c 바이트 고정 크기로)
    AddServerToList(서버정보);
}


UI에서의 분류 처리:

// UpdateServerListUI에서:
for (각_서버) {
    if (서버타입 == 0x00) {
        // PK 모드 서버 -> this + 0x274 컨테이너에 추가
        PK컨테이너에_추가(서버정보);
    } else if (서버타입 == 0x01) {
        // NPK 모드 서버 -> this + 0x284 컨테이너에 추가  
        NPK컨테이너에_추가(서버정보);
    }
}

// 각 모드별 최대 4개까지만 UI에 표시
PK모드_UI표시(최대4개);
NPK모드_UI표시(최대4개);


---
로그인 인증은 다음과 같은 흐름입니다:

서버 선택 → CMultiServerPacket(0x57) 전송
로그인 인증 → CLoginPacket(0x03) 전송
서버 응답 → STransferServerPacket(0x03) 수신
게임 서버 연결 → 새로운 IP/포트로 연결 후 CTransferServerPacket 전송

이제 로그인 서버에서 인증 후 실제 게임 서버로 연결이 전환되는 구조가 명확해졌습니다!
--로그인 인증은 다음과 같은 흐름입니다:

서버 선택 → CMultiServerPacket(0x57) 전송
로그인 인증 → CLoginPacket(0x03) 전송
서버 응답 → STransferServerPacket(0x03) 수신
게임 서버 연결 → 새로운 IP/포트로 연결 후 CTransferServerPacket 전송

이제 로그인 서버에서 인증 후 실제 게임 서버로 연결이 전환되는 구조가 명확해졌습니다!

-----
STransferServerPacket:
┌─────────────────────────────────────┐
│ [패킷 헤더]                         │
│   - 패킷 타입: 0x03                 │
├─────────────────────────────────────┤
│ [로그인 결과 분기]                  │
│   case 1: 로그인 성공               │
│     - 게임 서버 IP: 오프셋 0x24     │
│     - 게임 서버 포트: 오프셋 0x28   │
│     - 인증 토큰 길이: 오프셋 0x2a   │
│     - 인증 토큰 데이터: 오프셋 0x2b │
│                                     │
│   case 2: 로그인 실패               │
│     - NULL 패킷 또는 빈 데이터      │
│     - 에러 코드 (선택적)            │
└─────────────────────────────────────┘

-------
클라이언트 → 게임서버: CTransferServerPacket(인증토큰)
게임서버 → 클라이언트: SCheckPacket(인증결과)

if (인증성공) {
    게임서버 → 클라이언트: 각종 게임 데이터 패킷들
    - 캐릭터 정보
    - 맵 데이터  
    - 다른 플레이어 정보
    - 인벤토리 정보
    등등...
} else {
    에러 메시지 표시
}

-----------------
게임 화면 표시 후 서버에서 보내야 하는 필수 패킷들:

맵 정보 패킷들:

SMapSizePacket - 맵 크기 정보
SMapCRCPacket - 맵 데이터 무결성 체크
SMapStatusPacket - 맵 상태 정보


플레이어 캐릭터 정보:

SPutHumanObjectPacket - 플레이어 캐릭터 배치


인벤토리 및 장비 정보:

SAddInventoryPacket - 인벤토리 아이템들
SAddEquipmentPacket - 장착한 장비들


스킬 및 마법 정보:

SAddActionPacket - 보유 스킬/액션들
SAddLastingSpellPacket - 지속 효과 마법들


다른 플레이어 및 오브젝트:

SAddUserPacket - 주변 다른 플레이어들
기타 게임 오브젝트들



전송 순서:
1. 맵 정보 패킷들 (게임 월드 준비)
2. 플레이어 캐릭터 정보 (자신의 상태)
3. 인벤토리/장비 정보 (소유 아이템들)
4. 스킬/마법 정보 (능력치)
5. 주변 환경 정보 (다른 플레이어, 오브젝트)
이 패킷들이 모두 전송되어야 클라이언트에서 완전한 게임 화면을 표시하고 플레이할 수 있습니다.

1. CTransferServerPacket(인증토큰) 수신
2. 토큰 검증 성공
3. SCheckPacket(0) 전송 → InitializeGameWorld() 호출
4. 즉시 연속으로 필수 패킷들 전송:
   - SMapSizePacket
   - SMapCRCPacket  
   - SPutHumanObjectPacket
   - SAddInventoryPacket (여러 개)
   - SAddEquipmentPacket (여러 개)
   - SAddActionPacket (여러 개)
   - SAddUserPacket (주변 플레이어들)
   - 기타 게임 상태 패킷들

   ------------------------

   게임 초기화 완료 후 서버에서 자동 전송:

1. SMapCRCPacket (0x14)
   └─ 맵 파일 무결성 확인

2. SMapSizePacket (0x15) 
   └─ 맵 크기 및 기본 정보

3. SFieldMapPacket (0x2e)
   └─ 필드 맵 상세 정보 (지형, 오브젝트 등)

4. SPutHumanObjectPacket (0x33)
   └─ 플레이어 초기 위치 및 상태
   └─ X, Y 좌표, 방향, HP/MP 등

5. 기타 초기화 패킷들
   └─ SAddInventoryPacket (인벤토리)
   └─ SAddEquipmentPacket (장비)
   └─ SAddActionPacket (스킬)
   └─ SAddUserPacket (주변 플레이어)

   
  접속 후
**패킷 전송 시점:**
- ✅ **사용자 입력 시**: 이동, 공격, 아이템 사용 등
- ✅ **게임 이벤트 시**: 다른 플레이어 행동, 서버 이벤트 등
- ❌ **자동/주기적 전송**: 찾을 수 없음

따라서 **완전히 idle 상태에서는 패킷 전송이 없고**, 사용자가 행동을 취할 때만 해당 패킷이 전송됩니다.